LOL NOTES
weighting velocity average to 500 resulted in tight average velocity & wrecked COP
Removed constraint on time => Led to negative times
Fixed constraint on time to be positive => Initially a very slow first step, then much slower second step then very short 6 steps.
Trying time penalized =>very fast steps and Cost = 686
Without time penalized but having time constrained = > Cost = 185 (much better??? yet times were low enough in previous to have negligible effect on score and a time of 6 would only add 36 poitns leading to still less than 686 which is confusing)
Enforcing Standard deviation => 220 but weird looking and ugly and took a really long time
Replace STD with (min-mean) & (max-mean) => local minima with 110 but seemed pretty cool and regular step times only weight was 5 on v_av-xd
" also aquired a 105 local min run from zero not random

Pulled the things out of the for loop:
initial score of 60 with a weird result applying weights
added weight of 50 back to local minima around 105 and similar looking result
adjusted weights to be dependent on N


Changed the score on step duration to:
random_step = randi(length(step_dur));
score = score + 1*N*(step_dur(random_step)-mean(step_dur))^2 + 1*N*(step_dur(random_step)-mean(step_dur))^2;
the hope is that this will encourage all steps to share the same length as the rand ints will be "uniformly distributed". This may be better than just looking at the max and min, but it also might make the score function chaotic.Turns out this is really unstable, as it can grow and shrink dramatically in a random fashion. This really messes up the gradient.

Changed to the following, which will hopefully do better:


avstep_vec = ones(1,length(step_dur))*mean(step_dur)-step_dur;
score = score + 1*N*(avstep_vec*avstep_vec');
this should score the differences between all the steps from the average. It should also have a nice gradient. The deviation between each single step and the average won't be weighted as strongly and it won't perform as chaotically as checking the max and min. However, it will also tend to enforce the goal of consistent gait period more evenly. Results in a score of 90.9252 at a local min (probably). Still doing the weird 2 different step times thing, see below.
step_dur = [0.929700229640353	0.929700075091380	0.929700190449548	0.929700239631601	0.929700489722792	0.752966147551188	0.752966064046105	0.752966098234701]
Increasing the weight to 1.2 had a cool effect. Drove cost very low (32.0818). Behavior is strange, seems to override average velocity objective. Very consistent step time.
step_dur = [0.929700229640353	0.929700075091380	0.929700190449548	0.929700239631601	0.929700489722792	0.752966147551188	0.752966064046105	0.752966098234701]
Weighting 1.005 seemed to result in behavior similar to 'normal'. 1.01 is awful. Left it as 1.

Part 3
We altered our functions so that the planned steps were now considered desired and their was a cost associated with not being at those locations.
We then added new optimization variables for the footstep locations
To constrain them we initially constrained a initial x and a last x as in the start and the ending positions.
We then added a constraint that each x had to be larger then the last to prevent the it from walking backwards which we deemed incorrect
Initially the optimization could not find a feasible solution which didn't make sense as all of our constraints would have been aceptable with the original plan which we also gave as our starting point.
We found that by changing the starting plan to all zeros and then also weighting the footstep location accuracy higher we could get it to find a feasible solution
This solution still was not good as the y location started very high and did not decrease much over the course of the walk.
Our first attempt at fixing this was to also constrain the y positions for the first and last steps.
